<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customization - Market Screener Documentation</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
</head>
<body>
    <div class="documentation-container">
        <!-- Left Sidebar - Table of Contents -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>üöÄ Market Screener</h1>
                <p>Technical Documentation</p>
            </div>
            
            <nav class="toc">
                <div class="toc-section">
                    <a href="index.html" class="toc-main">üè† Home</a>
                </div>
                
                <div class="toc-section">
                    <a href="executive-summary.html" class="toc-main">üìã Executive Summary</a>
                    <a href="executive-summary.html#project-overview" class="toc-sub">Project Overview</a>
                    <a href="executive-summary.html#key-features" class="toc-sub">Key Features</a>
                </div>
                
                <div class="toc-section">
                    <a href="technology-stack.html" class="toc-main">üíª Technology Stack</a>
                    <a href="technology-stack.html#backend-tech" class="toc-sub">Backend Technologies</a>
                    <a href="technology-stack.html#frontend-tech" class="toc-sub">Frontend Technologies</a>
                    <a href="technology-stack.html#why-typescript" class="toc-sub">Why TypeScript</a>
                </div>
                
                <div class="toc-section">
                    <a href="architecture.html" class="toc-main">üèóÔ∏è System Architecture</a>
                    <a href="architecture.html#high-level-arch" class="toc-sub">High-Level Architecture</a>
                    <a href="architecture.html#data-flow-arch" class="toc-sub">Data Flow Architecture</a>
                </div>
                
                <div class="toc-section">
                    <a href="backend-docs.html" class="toc-main">‚öôÔ∏è Backend Documentation</a>
                    <a href="backend-docs.html#root-files" class="toc-sub">Root Files</a>
                    <a href="backend-docs.html#configuration" class="toc-sub">Configuration</a>
                    <a href="backend-docs.html#controllers" class="toc-sub">Controllers</a>
                    <a href="backend-docs.html#middleware" class="toc-sub">Middleware</a>
                    <a href="backend-docs.html#models" class="toc-sub">Models</a>
                    <a href="backend-docs.html#routes" class="toc-sub">Routes</a>
                    <a href="backend-docs.html#services" class="toc-sub">Services</a>
                    <a href="backend-docs.html#alerts" class="toc-sub">Alerts</a>
                    <a href="backend-docs.html#jobs" class="toc-sub">Jobs</a>
                    <a href="backend-docs.html#utils" class="toc-sub">Utils</a>
                </div>
                
                <div class="toc-section">
                    <a href="frontend-docs.html" class="toc-main">üé® Frontend Documentation</a>
                    <a href="frontend-docs.html#pages" class="toc-sub">Pages</a>
                    <a href="frontend-docs.html#components" class="toc-sub">Components</a>
                    <a href="frontend-docs.html#context" class="toc-sub">Context</a>
                    <a href="frontend-docs.html#hooks" class="toc-sub">Hooks</a>
                </div>
                
                <div class="toc-section">
                    <a href="api-docs.html" class="toc-main">üîå API Documentation</a>
                    <a href="api-docs.html#auth-endpoints" class="toc-sub">Authentication</a>
                    <a href="api-docs.html#user-endpoints" class="toc-sub">User Management</a>
                    <a href="api-docs.html#alert-endpoints" class="toc-sub">Alert System</a>
                    <a href="api-docs.html#decision-endpoints" class="toc-sub">Decisions</a>
                </div>
                
                <div class="toc-section">
                    <a href="database-schema.html" class="toc-main">üóÑÔ∏è Database Schema</a>
                    <a href="database-schema.html#mongodb-collections" class="toc-sub">MongoDB Collections</a>
                    <a href="database-schema.html#redis-structures" class="toc-sub">Redis Structures</a>
                </div>
                
                <div class="toc-section">
                    <a href="configuration.html" class="toc-main">‚öôÔ∏è Configuration</a>
                    <a href="configuration.html#env-variables" class="toc-sub">Environment Variables</a>
                    <a href="configuration.html#config-categories" class="toc-sub">Config Categories</a>
                </div>
                
                <div class="toc-section">
                    <a href="deployment.html" class="toc-main">üöÄ Deployment Guide</a>
                    <a href="deployment.html#prerequisites" class="toc-sub">Prerequisites</a>
                    <a href="deployment.html#installation" class="toc-sub">Installation</a>
                    <a href="deployment.html#production" class="toc-sub">Production</a>
                </div>
                
                <div class="toc-section">
                    <a href="customization.html" class="toc-main active">üîß Customization</a>
                    <a href="#new-alerts" class="toc-sub">New Alert Types</a>
                    <a href="#trading-strategies" class="toc-sub">Trading Strategies</a>
                    <a href="#ui-extension" class="toc-sub">UI Extension</a>
                </div>
            </nav>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="header">
                <h1>üîß Customization</h1>
                <p>Extending & Customizing the System</p>
            </div>
            
            <div class="content">
                <!-- Customization -->
                <div class="section" id="customization">
                    <h2>üîß 10. Customization</h2>

                    <div class="overview-grid">
                        <div class="overview-card">
                            <h3>üö® Alert Types</h3>
                            <p>Adding custom alert conditions and triggers</p>
                        </div>
                        
                        <div class="overview-card">
                            <h3>üìà Trading Strategies</h3>
                            <p>Implementing custom trading algorithms</p>
                        </div>
                        
                        <div class="overview-card">
                            <h3>üé® UI Extensions</h3>
                            <p>Customizing the user interface and components</p>
                        </div>
                    </div>

                    <h3 id="new-alerts">Adding New Alert Types</h3>
                    <p>Extend the system with custom alert conditions by following these steps:</p>
                    
                    <div class="api-endpoint">
                        <h4>1. Create Alert Type Definition</h4>
                        <div class="code-block">
// src/alerts/types/customAlert.ts
export interface CustomAlertConfig {
    type: 'custom';
    symbol: string;
    condition: 'above' | 'below' | 'crosses';
    threshold: number;
    timeframe: '1m' | '5m' | '15m' | '1h' | '1d';
    enabled: boolean;
}

export class CustomAlertProcessor {
    async process(data: MarketData, config: CustomAlertConfig): Promise<AlertResult> {
        // Implement your custom logic here
        const currentValue = this.calculateCustomIndicator(data);
        
        if (this.checkCondition(currentValue, config)) {
            return {
                triggered: true,
                message: `Custom alert triggered for ${config.symbol}`,
                data: { value: currentValue, threshold: config.threshold }
            };
        }
        
        return { triggered: false };
    }
    
    private calculateCustomIndicator(data: MarketData): number {
        // Your custom calculation logic
        return 0;
    }
    
    private checkCondition(value: number, config: CustomAlertConfig): boolean {
        switch (config.condition) {
            case 'above': return value > config.threshold;
            case 'below': return value < config.threshold;
            case 'crosses': return Math.abs(value - config.threshold) < 0.01;
            default: return false;
        }
    }
}
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>2. Register Alert Type</h4>
                        <div class="code-block">
// src/alerts/alertManager.ts
import { CustomAlertProcessor } from './types/customAlert';

export class AlertManager {
    private processors = new Map<string, any>();
    
    constructor() {
        this.registerProcessor('custom', new CustomAlertProcessor());
    }
    
    registerProcessor(type: string, processor: any) {
        this.processors.set(type, processor);
    }
}
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>3. Add API Endpoint</h4>
                        <div class="code-block">
// src/routes/alerts.ts
router.post('/custom', auth, async (req, res) => {
    try {
        const config: CustomAlertConfig = {
            type: 'custom',
            symbol: req.body.symbol,
            condition: req.body.condition,
            threshold: req.body.threshold,
            timeframe: req.body.timeframe,
            enabled: true
        };
        
        const alert = await AlertService.createAlert(req.user.id, config);
        res.json(alert);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});
                        </div>
                    </div>

                    <h3 id="trading-strategies">Implementing Custom Trading Strategies</h3>
                    <p>Create custom trading strategies by extending the decision engine:</p>
                    
                    <div class="api-endpoint">
                        <h4>1. Strategy Interface</h4>
                        <div class="code-block">
// src/services/strategies/baseStrategy.ts
export interface StrategyConfig {
    name: string;
    enabled: boolean;
    parameters: Record<string, any>;
}

export interface StrategyResult {
    action: 'buy' | 'sell' | 'hold';
    confidence: number;
    reason: string;
    parameters: Record<string, any>;
}

export abstract class BaseStrategy {
    abstract analyze(data: MarketData, config: StrategyConfig): Promise<StrategyResult>;
    abstract validateConfig(config: StrategyConfig): boolean;
}
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>2. Custom Strategy Implementation</h4>
                        <div class="code-block">
// src/services/strategies/movingAverageCrossover.ts
export class MovingAverageCrossoverStrategy extends BaseStrategy {
    async analyze(data: MarketData, config: StrategyConfig): Promise<StrategyResult> {
        const shortMA = this.calculateMA(data.close, config.parameters.shortPeriod);
        const longMA = this.calculateMA(data.close, config.parameters.longPeriod);
        
        if (shortMA > longMA && config.parameters.lastSignal !== 'buy') {
            return {
                action: 'buy',
                confidence: 0.8,
                reason: 'Short MA crossed above long MA',
                parameters: { shortMA, longMA }
            };
        }
        
        if (shortMA < longMA && config.parameters.lastSignal !== 'sell') {
            return {
                action: 'sell',
                confidence: 0.8,
                reason: 'Short MA crossed below long MA',
                parameters: { shortMA, longMA }
            };
        }
        
        return {
            action: 'hold',
            confidence: 0.5,
            reason: 'No crossover detected',
            parameters: { shortMA, longMA }
        };
    }
    
    validateConfig(config: StrategyConfig): boolean {
        return config.parameters.shortPeriod < config.parameters.longPeriod;
    }
    
    private calculateMA(prices: number[], period: number): number {
        const sum = prices.slice(-period).reduce((a, b) => a + b, 0);
        return sum / period;
    }
}
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>3. Strategy Registration</h4>
                        <div class="code-block">
// src/services/decisionEngine.ts
import { MovingAverageCrossoverStrategy } from './strategies/movingAverageCrossover';

export class DecisionEngine {
    private strategies = new Map<string, BaseStrategy>();
    
    constructor() {
        this.registerStrategy('ma-crossover', new MovingAverageCrossoverStrategy());
    }
    
    registerStrategy(name: string, strategy: BaseStrategy) {
        this.strategies.set(name, strategy);
    }
    
    async analyze(symbol: string, data: MarketData): Promise<DecisionResult> {
        const results = [];
        
        for (const [name, strategy] of this.strategies) {
            const config = await this.getStrategyConfig(symbol, name);
            if (config.enabled) {
                const result = await strategy.analyze(data, config);
                results.push({ strategy: name, ...result });
            }
        }
        
        return this.aggregateResults(results);
    }
}
                        </div>
                    </div>

                    <h3 id="ui-extension">Extending the User Interface</h3>
                    <p>Add custom UI components and pages to the React frontend:</p>
                    
                    <div class="api-endpoint">
                        <h4>1. Custom Component</h4>
                        <div class="code-block">
// src/components/CustomChart.tsx
import React from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip } from 'recharts';

interface CustomChartProps {
    data: any[];
    title: string;
    height?: number;
}

export const CustomChart: React.FC<CustomChartProps> = ({ data, title, height = 300 }) => {
    return (
        <div className="bg-white rounded-lg shadow-md p-4">
            <h3 className="text-lg font-semibold mb-4">{title}</h3>
            <LineChart width={600} height={height} data={data}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="time" />
                <YAxis />
                <Tooltip />
                <Line type="monotone" dataKey="value" stroke="#8884d8" />
            </LineChart>
        </div>
    );
};
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>2. Custom Page</h4>
                        <div class="code-block">
// src/pages/CustomAnalysis.tsx
import React, { useState, useEffect } from 'react';
import { CustomChart } from '../components/CustomChart';
import { useAuth } from '../contexts/AuthContext';

export const CustomAnalysis: React.FC = () => {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(false);
    const { user } = useAuth();
    
    useEffect(() => {
        fetchCustomData();
    }, []);
    
    const fetchCustomData = async () => {
        setLoading(true);
        try {
            const response = await fetch('/api/custom-analysis', {
                headers: { 'Authorization': `Bearer ${user.token}` }
            });
            const result = await response.json();
            setData(result.data);
        } catch (error) {
            console.error('Error fetching custom data:', error);
        } finally {
            setLoading(false);
        }
    };
    
    return (
        <div className="container mx-auto p-6">
            <h1 className="text-2xl font-bold mb-6">Custom Analysis</h1>
            {loading ? (
                <div>Loading...</div>
            ) : (
                <CustomChart data={data} title="Custom Analysis Chart" />
            )}
        </div>
    );
};
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>3. Add Route</h4>
                        <div class="code-block">
// src/App.tsx
import { CustomAnalysis } from './pages/CustomAnalysis';

function App() {
    return (
        <Router>
            <Routes>
                <Route path="/custom-analysis" element={<CustomAnalysis />} />
                {/* ... other routes */}
            </Routes>
        </Router>
    );
}
                        </div>
                    </div>

                    <h3>Integrating External Data Sources</h3>
                    <p>Add new data providers to expand market coverage:</p>
                    
                    <div class="api-endpoint">
                        <h4>1. Data Provider Interface</h4>
                        <div class="code-block">
// src/services/dataProviders/baseProvider.ts
export interface DataProviderConfig {
    apiKey: string;
    baseUrl: string;
    rateLimit: number;
}

export interface MarketDataRequest {
    symbol: string;
    interval: string;
    limit: number;
}

export abstract class BaseDataProvider {
    abstract fetchData(request: MarketDataRequest): Promise<MarketData>;
    abstract validateConfig(config: DataProviderConfig): boolean;
}
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>2. Custom Provider Implementation</h4>
                        <div class="code-block">
// src/services/dataProviders/customProvider.ts
export class CustomDataProvider extends BaseDataProvider {
    private config: DataProviderConfig;
    
    constructor(config: DataProviderConfig) {
        super();
        this.config = config;
    }
    
    async fetchData(request: MarketDataRequest): Promise<MarketData> {
        const response = await fetch(`${this.config.baseUrl}/data`, {
            headers: {
                'Authorization': `Bearer ${this.config.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(request)
        });
        
        if (!response.ok) {
            throw new Error(`API request failed: ${response.statusText}`);
        }
        
        const data = await response.json();
        return this.transformData(data);
    }
    
    validateConfig(config: DataProviderConfig): boolean {
        return !!config.apiKey && !!config.baseUrl;
    }
    
    private transformData(rawData: any): MarketData {
        // Transform raw API data to internal format
        return {
            symbol: rawData.symbol,
            timestamp: new Date(rawData.timestamp),
            open: parseFloat(rawData.open),
            high: parseFloat(rawData.high),
            low: parseFloat(rawData.low),
            close: parseFloat(rawData.close),
            volume: parseInt(rawData.volume)
        };
    }
}
                        </div>
                    </div>

                    <h3>Modifying Business Logic</h3>
                    <p>Customize core business logic for specific requirements:</p>
                    
                    <div class="api-endpoint">
                        <h4>1. Position Management Customization</h4>
                        <div class="code-block">
// src/services/positionManager.ts
export class CustomPositionManager extends PositionManager {
    async calculateExitPrice(position: Position, marketData: MarketData): Promise<number> {
        // Custom exit logic based on volatility
        const volatility = this.calculateVolatility(marketData);
        
        if (volatility > 0.05) {
            // High volatility - tighter stop loss
            return position.entryPrice * (position.side === 'long' ? 0.95 : 1.05);
        } else {
            // Low volatility - standard exit
            return super.calculateExitPrice(position, marketData);
        }
    }
    
    private calculateVolatility(data: MarketData): number {
        // Implement volatility calculation
        return 0.03;
    }
}
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>2. Risk Management Rules</h4>
                        <div class="code-block">
// src/services/riskManager.ts
export class CustomRiskManager extends RiskManager {
    async validateTrade(trade: TradeRequest): Promise<RiskValidation> {
        const baseValidation = await super.validateTrade(trade);
        
        // Custom risk rules
        const maxPositionSize = this.calculateMaxPositionSize(trade.userId);
        const currentExposure = await this.getCurrentExposure(trade.userId);
        
        if (currentExposure + trade.amount > maxPositionSize) {
            return {
                valid: false,
                reason: 'Exceeds maximum position size',
                details: { currentExposure, maxPositionSize }
            };
        }
        
        return baseValidation;
    }
    
    private calculateMaxPositionSize(userId: string): number {
        // Custom position sizing logic
        return 10000; // $10,000 max position
    }
}
                        </div>
                    </div>

                    <h3>Adding New API Endpoints</h3>
                    <p>Extend the API with custom endpoints for new functionality:</p>
                    
                    <div class="api-endpoint">
                        <h4>1. Custom Route Definition</h4>
                        <div class="code-block">
// src/routes/custom.ts
import express from 'express';
import { auth } from '../middleware/auth';

const router = express.Router();

// Custom analysis endpoint
router.get('/analysis/:symbol', auth, async (req, res) => {
    try {
        const { symbol } = req.params;
        const analysis = await CustomAnalysisService.generate(symbol);
        res.json(analysis);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Custom report endpoint
router.post('/reports', auth, async (req, res) => {
    try {
        const report = await ReportService.generate(req.body, req.user.id);
        res.json(report);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

export default router;
                        </div>
                    </div>

                    <div class="api-endpoint">
                        <h4>2. Register Routes</h4>
                        <div class="code-block">
// src/app.ts
import customRoutes from './routes/custom';

app.use('/api/custom', customRoutes);
                        </div>
                    </div>

                    <h3>Customizing Notification Channels</h3>
                    <p>Add new notification methods beyond email and push:</p>
                    
                    <div class="api-endpoint">
                        <h4>1. Custom Notification Provider</h4>
                        <div class="code-block">
// src/services/notifications/customProvider.ts
export interface NotificationConfig {
    webhookUrl: string;
    channel: string;
    format: 'json' | 'text';
}

export class CustomNotificationProvider implements NotificationProvider {
    async send(notification: Notification, config: NotificationConfig): Promise<boolean> {
        try {
            const payload = this.formatPayload(notification, config);
            
            const response = await fetch(config.webhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            return response.ok;
        } catch (error) {
            console.error('Custom notification failed:', error);
            return false;
        }
    }
    
    private formatPayload(notification: Notification, config: NotificationConfig): any {
        if (config.format === 'json') {
            return {
                channel: config.channel,
                message: notification.message,
                data: notification.data,
                timestamp: new Date().toISOString()
            };
        } else {
            return {
                text: `${notification.message}\n${JSON.stringify(notification.data)}`
            };
        }
    }
}
                        </div>
                    </div>

                    <div class="highlight-box">
                        <h4>Best Practices for Customization</h4>
                        <ul>
                            <li><strong>Follow existing patterns:</strong> Maintain consistency with current code structure</li>
                            <li><strong>Add proper error handling:</strong> Implement comprehensive error handling for custom features</li>
                            <li><strong>Include validation:</strong> Validate all inputs and configurations</li>
                            <li><strong>Add logging:</strong> Include appropriate logging for debugging and monitoring</li>
                            <li><strong>Test thoroughly:</strong> Create unit tests for custom functionality</li>
                            <li><strong>Document changes:</strong> Update documentation for any new features</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid diagrams
        mermaid.initialize({ startOnLoad: true });
        
        // Add active class to current page in navigation
        document.addEventListener('DOMContentLoaded', function() {
            const currentPage = window.location.pathname.split('/').pop() || 'index.html';
            const navLinks = document.querySelectorAll('.toc-main');
            
            navLinks.forEach(link => {
                if (link.getAttribute('href') === currentPage) {
                    link.classList.add('active');
                }
            });
        });

        // Add zoom functionality to diagrams
        function addZoomControls() {
            const diagrams = document.querySelectorAll('.mermaid');
            diagrams.forEach((diagram, index) => {
                const container = diagram.closest('.diagram-container');
                if (container && !container.querySelector('.zoom-controls')) {
                    const zoomControls = document.createElement('div');
                    zoomControls.className = 'zoom-controls';
                    zoomControls.innerHTML = `
                        <button class="zoom-btn" onclick="zoomDiagram(${index}, 1.5)">Zoom In</button>
                        <button class="zoom-btn" onclick="zoomDiagram(${index}, 1)">Reset</button>
                        <button class="zoom-btn" onclick="fullscreenDiagram(${index})">Fullscreen</button>
                    `;
                    container.appendChild(zoomControls);
                }
            });
        }

        function zoomDiagram(index, scale) {
            const diagrams = document.querySelectorAll('.mermaid');
            if (diagrams[index]) {
                diagrams[index].style.transform = `scale(${scale})`;
                diagrams[index].classList.toggle('zoomed', scale !== 1);
            }
        }

        function fullscreenDiagram(index) {
            const diagrams = document.querySelectorAll('.mermaid');
            if (diagrams[index]) {
                const diagram = diagrams[index];
                diagram.classList.toggle('fullscreen');
                
                if (diagram.classList.contains('fullscreen')) {
                    // Add close button for fullscreen
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'zoom-btn';
                    closeBtn.textContent = 'Close';
                    closeBtn.style.position = 'fixed';
                    closeBtn.style.top = '20px';
                    closeBtn.style.left = '20px';
                    closeBtn.style.zIndex = '10000';
                    closeBtn.onclick = () => {
                        diagram.classList.remove('fullscreen');
                        closeBtn.remove();
                    };
                    document.body.appendChild(closeBtn);
                }
            }
        }

        // Initialize zoom controls after Mermaid renders
        setTimeout(addZoomControls, 1000);
    </script>
</body>
</html>
